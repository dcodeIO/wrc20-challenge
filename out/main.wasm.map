{"version":3,"sources":["~lib/internal/allocator.ts","~lib/allocator/arena.ts","main.ts"],"names":[],"mappings":"oQCgBE,AAAI,IACF,AAAI,EAAO,SAAa,EACxB,AAAU,IACV,AAAa,AAAC,EAAM,GAAO,GAAW,AAAC,QACvC,AAAkB,IAClB,AAAI,EAAS,EAAsB,MACjC,AAAkB,AAAC,AAAC,EAAS,GAAM,KAAU,AAAC,QAAY,KAC1D,AAAkB,AAAI,IAAa,YACnC,AAAI,AAAY,IAAe,KAAG,AAC5B,AAAY,IAAe,KAAG,IAKtC,AAAS,IACF,IAEF,OCIP,AAAI,EAA+B,KACjC,AAAgB,EAAG,KAErB,AAAuB,AAAgB,MACvC,AAAsB,EAAY,EAAG,IACrC,AAAoB,AAAU,OAG9B,AAAuB,AAAgB,MACvC,AAAqB,EAAS,IAC9B,AAAgB,EAAY,OAGD,MAhC3B,AAAI,EAA6B,KAC/B,AAAgB,EAAG,KAErB,AAAwB,AAAgB,MACxC,AAAsB,EAAa,EAAG,IACtC,AAAqB,AAAU,OAC/B,QAAO,MACA,WAGA,YAFH,EACA,GAEA,EACA,GAEA,AAAgB,EAAG,QDrBA,AAAC,EAAY,GAAW,AAAC,QAC9B","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\nexport const AL_BITS: u32 = 3;\n\n/** Number of possible alignment values. */\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\n\n/** Mask to obtain just the alignment bits. */\nexport const AL_MASK: usize = AL_SIZE - 1;\n\n/** Maximum 32-bit allocation size. */\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\n","/**\n * Arena Memory Allocator\n *\n * Provides a `reset_memory` function to reset the heap to its initial state. A user has to make\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/arena\n *//***/\n\nimport { AL_MASK, MAX_SIZE_32 } from \"../internal/allocator\";\n\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\nvar offset: usize = startOffset;\n\n@global\nexport function allocate_memory(size: usize): usize {\n  if (size) {\n    if (size > MAX_SIZE_32) unreachable();\n    let ptr = offset;\n    let newPtr = (ptr + size + AL_MASK) & ~AL_MASK;\n    let pagesBefore = current_memory();\n    if (newPtr > <usize>pagesBefore << 16) {\n      let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\n      let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n      if (grow_memory(pagesWanted) < 0) {\n        if (grow_memory(pagesNeeded) < 0) {\n          unreachable(); // out of memory\n        }\n      }\n    }\n    offset = newPtr;\n    return ptr;\n  }\n  return 0;\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  // nop\n}\n\n@global\nexport function reset_memory(): void {\n  offset = startOffset;\n}\n","import 'allocator/arena';\n\n// ewasm imports\ndeclare function ethereum_return(dataOffset: i32, length: i32): void;\ndeclare function ethereum_revert(dataOffset: i32, length: i32): void;\ndeclare function ethereum_callDataCopy(resultOffset: i32, dataOffset: i32, length: i32): void;\ndeclare function ethereum_getCallDataSize(): i32;\ndeclare function ethereum_storageStore(pathOffset: i32, valueOffset: i32): void;\ndeclare function ethereum_storageLoad(pathOffset: i32, resultOffset: i32): void;\n\n// TODO: need to implement a nice wrapper over the native functions which use native types and handles the memory.\n\n// ewasm main function\nexport function main(): void {\n  // assume the memory is already expanded..\n  // ethereum_return(0, ethereum_callDataSize())\n\n  // Make sure we have enough args\n  if (ethereum_getCallDataSize() < 4)\n    ethereum_revert(0, 0);\n\n  var ptrSelector : i32 = allocate_memory(4);\n  ethereum_callDataCopy(ptrSelector, 0, 4);\n  var selector : i32 = load<i32>(ptrSelector);\n  switch(selector) {\n    case 0x9993021a:\n      do_balance();\n      break;\n    case 0x5d359fbd:\n      do_transfer();\n      break;\n    default:\n      ethereum_revert(0, 0);\n  }\n}\n\nfunction do_balance(): void {\n  if (ethereum_getCallDataSize() !== 24)\n    ethereum_revert(0, 0);\n\n  var ptrAddress : i32 = allocate_memory(20);\n  ethereum_callDataCopy(ptrAddress, 4, 20);\n  var address : i32 = load<i32>(ptrAddress);\n  // make sure that address is 160 bits here,\n  // but storage key is 256 bits so need to pad it somehow\n  var ptrBalance : i32 = allocate_memory(32);\n  ethereum_storageLoad(address, ptrBalance);\n  ethereum_return(ptrBalance, 32);\n}\n\nfunction do_transfer(): void {\n\n}\n"]}